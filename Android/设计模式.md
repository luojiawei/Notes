# 设计模式

### 1、组合模式

组合模式(Composite Pattern)有时候又叫做部分-整体模式，它使我们树型结构的问题中，模糊了简单元素和复杂元素的概念。

##### Android源码中的组合模式

组合模式在Android中太常用了，View和ViewGroup就是一种很标准的组合模式：

![image](https://github.com/luojiawei/Notes/blob/master/Android/Picture/组合模式.png)

在Android的视图树中，容器一定是ViewGroup，只有ViewGroup才能包含其他View和ViewGroup。View是没有容器的。者是一种安全的组合模式。

### 2、观察者模式

定义对象间的一种一个(Observable)对多(Observer)的依赖关系，当一个对象的状态发送改变时，所以依赖于它的对象都得到通知并被自动更新。

##### Android源码中的观察者模式
通常在ListView的内容变化时，我们会调用notifyDataSetChanged()这个方法，然后ListView里面的数据就会进行更新。这个感觉就像是观察者模式。ListView在观察者内容，内容变化发布通知之后ListView就会更新数据。

看一下这个方法。


```
package android.widget;
public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter {
    private final DataSetObservable mDataSetObservable = new DataSetObservable();
    public void registerDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.registerObserver(observer);
    }

    public void unregisterDataSetObserver(DataSetObserver observer) {
        mDataSetObservable.unregisterObserver(observer);
    }
    ......
    public void notifyDataSetChanged() {
        mDataSetObservable.notifyChanged();
    }
    ......
}
```

这段代码可以看到这应该是一个观察者模式，而且这个一个被观察者，里面提供了注册和注销观察者以及通知观察者的方法。

这些方法是通过DataSetObservable这个类调用的：


```
package android.database;
public class DataSetObservable extends Observable<DataSetObserver> {   
    public void notifyChanged() {
        synchronized(mObservers) {
            for (int i = mObservers.size() - 1; i >= 0; i--) {
                mObservers.get(i).onChanged();
            }
        }
    }
    ......
}
```
这个类继承自Observable，Observable中有一个protected final ArrayList<T> mObservers = new ArrayList<T>();, 
用来保存注册的观察者。mDataSetObservable.registerObserver(observer)和mDataSetObservable.unregisterObserver(observer)分别就是增加和删除。

### 3、单例模式

Singleton 是一种创建型模式，指某个类采用 Singleton 模式，则在这个类被创 建后，只可能产生一个实例供外部访问，并且提供一个全局的访问点。全局对象和 Singleton 模式有本质的区别，因为大量使用全局对象会使得程序质量降低，而且有些编程语言根本不支持全局变量。最重要的是传统的全局对象并不能阻止一个类被实例化多次。

##### Android源码中的单例模式

我们经常通过context.getSystemService(String name)来获取一些系统服务，如在Activity中获取ActivityManager：


```
ActivityManager  mActivityManager = (ActivityManager) getSystemService(Context.ACTIVITY_SERVICE);
```


书中举例为LayoutInflater，平时获取方式为LayoutInflater.from(context),看下这个方法：


```
package android.view;
public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater =
            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    if (LayoutInflater == null) {
        throw new AssertionError("LayoutInflater not found.");
    }
    return LayoutInflater;
}
```

发现也是通过调用context.getSystemService(String name)获取的。
### 4、模板方法模式

定义一个操作中算法的骨架，而将一些步骤延迟到子类中，模板方法使得子类可以不改变算法的结构即可重定义该算法的某些特定步骤。

通俗点的理解就是 ：完成一件事情，有固定的数个步骤，但是每个步骤根据对象的不同，而实现细节不同；就可以在父类中定义一个完成该事情的总方法，按照完成事件需要的步骤去调用其每个步骤的实现方法。每个步骤的具体实现，由子类完成。

##### Android中的模板方法

常用的AsyncTask的使用方法是这样的：


```
class MyAsynctask extends AsyncTask{

    @Override
    protected void onPreExecute() {
        super.onPreExecute();
    }

    @Override
    protected Object doInBackground(Object[] params) {
        return null;
    }

    @Override
    protected void onPostExecute(Object o) {
        super.onPostExecute(o);
    }
}
```


通常要重写者三个方法。AsyncTask的执行过程就是一个逻辑流程，在这个过程中会在适当的时候执行者三个方法，这个过程是固定的。但是子类可以通过重写者三个方法来改变具体的执行内容。

[设计模式之 - 模板模式（Template Pattern）](https://www.cnblogs.com/qq-361807535/p/6854191.html)

### 5、备忘录模式

在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。

##### Android中的备忘录模式

在Activity中有这两个方法：
    
```Java
    
@Override
public void onSaveInstanceState(Bundle outState, PersistableBundle outPersistentState) {
    super.onSaveInstanceState(outState, outPersistentState);
}

@Override
protected void onRestoreInstanceState(Bundle savedInstanceState) {
    super.onRestoreInstanceState(savedInstanceState);
}
```
